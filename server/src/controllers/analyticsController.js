/**
 * @fileoverview Analytics Controller - Retrieves processed analytics from Spark
 * @module controllers/analyticsController
 * @description
 * Handles HTTP requests for retrieving analytics data generated by Apache Spark.
 * Provides endpoints for fetching latest analytics and querying historical data.
 *
 * Features:
 * - Get latest analytics for specific metric type
 * - Get all analytics with optional filtering
 * - Get analytics by time range
 * - Get anomaly reports
 * - Get streak leaderboards
 *
 * All endpoints are protected by JWT authentication.
 *
 * @requires models/Analytics
 * @requires middleware/errorHandler
 * @created 2025-11-16
 * @updated 2025-11-16
 */

import Analytics from '../models/Analytics.js';
import { asyncHandler, ErrorResponse } from '../middleware/errorHandler.js';
import mongoose from 'mongoose';

/**
 * @desc    Get latest analytics for a specific metric type
 * @route   GET /api/analytics/latest/:metricType
 * @access  Private (JWT protected)
 * @param   {string} req.params.metricType - Metric type (steps, calories, etc.)
 * @param   {string} req.query.timeRange - Optional time range filter (7day, 30day, 90day)
 * @returns {Object} Latest analytics document
 *
 * @example
 * GET /api/analytics/latest/steps?timeRange=7day
 * Authorization: Bearer <token>
 *
 * Response 200:
 * {
 *   "success": true,
 *   "data": {
 *     "_id": "...",
 *     "userId": "...",
 *     "metricType": "steps",
 *     "timeRange": "7day",
 *     "analytics": { ... },
 *     "calculatedAt": "2025-11-16T19:00:00Z"
 *   }
 * }
 */
export const getLatestAnalytics = asyncHandler(async (req, res, next) => {
  const { metricType } = req.params;
  const { timeRange } = req.query;

  // Validate metric type (must match Analytics model enum)
  const validMetricTypes = ['steps', 'distance', 'calories', 'activeMinutes', 'weight', 'sleepHours', 'heartPoints', 'hydration'];

  if (!validMetricTypes.includes(metricType)) {
    return next(
      new ErrorResponse(
        `Invalid metric type: ${metricType}. Must be one of: ${validMetricTypes.join(', ')}`,
        400
      )
    );
  }

  // Build query
  const query = {
    userId: req.user.id,
    metricType: metricType.toLowerCase()
  };

  // Add timeRange filter if provided
  if (timeRange) {
    const validTimeRanges = ['7day', '30day', '90day'];

    if (!validTimeRanges.includes(timeRange)) {
      return next(
        new ErrorResponse(
          `Invalid time range: ${timeRange}. Must be one of: ${validTimeRanges.join(', ')}`,
          400
        )
      );
    }

    query.timeRange = timeRange;
  }

  // Query latest analytics
  const analytics = await Analytics.findOne(query)
    .sort({ calculatedAt: -1 })  // Newest first
    .limit(1)
    .exec();

  // Return null if no analytics found (not an error - just no data yet)
  if (!analytics) {
    return res.status(200).json({
      success: true,
      data: null,
      message: `No analytics available for ${metricType}${timeRange ? ` (${timeRange})` : ''}`
    });
  }

  res.status(200).json({
    success: true,
    data: analytics
  });
});

/**
 * @desc    Get all analytics for authenticated user
 * @route   GET /api/analytics
 * @access  Private (JWT protected)
 * @query   {string} metricType - Optional: Filter by metric type
 * @query   {string} timeRange - Optional: Filter by time range (7day, 30day, 90day)
 * @query   {boolean} anomaliesOnly - Optional: Return only entries with anomalies
 * @query   {number} limit - Optional: Limit results (default: 100, max: 500)
 * @query   {number} skip - Optional: Skip results for pagination (default: 0)
 * @query   {string} startDate - Optional: Filter by calculatedAt >= startDate (ISO 8601)
 * @query   {string} endDate - Optional: Filter by calculatedAt <= endDate (ISO 8601)
 * @query   {string} sortBy - Optional: Sort field (default: calculatedAt)
 * @query   {string} sortOrder - Optional: Sort order (asc/desc, default: desc)
 * @returns {Array} Array of analytics documents
 *
 * @example
 * GET /api/analytics?metricType=steps&timeRange=7day&limit=50
 * Authorization: Bearer <token>
 *
 * Response 200:
 * {
 *   "success": true,
 *   "count": 10,
 *   "data": [ ... ],
 *   "pagination": {
 *     "limit": 50,
 *     "skip": 0,
 *     "total": 10
 *   }
 * }
 */
export const getAllAnalytics = asyncHandler(async (req, res, next) => {
  const {
    metricType,
    timeRange,
    anomaliesOnly,
    limit = 100,
    skip = 0,
    startDate,
    endDate,
    sortBy = 'calculatedAt',
    sortOrder = 'desc'
  } = req.query;

  // Build query
  const query = { userId: req.user.id };

  // Filter by metric type
  if (metricType) {
    const validMetricTypes = ['steps', 'distance', 'calories', 'activeMinutes', 'weight', 'sleepHours', 'heartPoints', 'hydration'];

    if (!validMetricTypes.includes(metricType)) {
      return next(
        new ErrorResponse(
          `Invalid metric type: ${metricType}`,
          400
        )
      );
    }

    query.metricType = metricType.toLowerCase();
  }

  // Filter by time range
  if (timeRange) {
    const validTimeRanges = ['7day', '30day', '90day'];

    if (!validTimeRanges.includes(timeRange)) {
      return next(
        new ErrorResponse(
          `Invalid time range: ${timeRange}`,
          400
        )
      );
    }

    query.timeRange = timeRange;
  }

  // Filter by anomalies only
  if (anomaliesOnly === 'true') {
    query['analytics.anomalyDetected'] = true;
  }

  // Date range filtering
  if (startDate || endDate) {
    query.calculatedAt = {};

    if (startDate) {
      const start = new Date(startDate);

      if (isNaN(start.getTime())) {
        return next(new ErrorResponse('Invalid startDate format. Use ISO 8601.', 400));
      }

      query.calculatedAt.$gte = start;
    }

    if (endDate) {
      const end = new Date(endDate);

      if (isNaN(end.getTime())) {
        return next(new ErrorResponse('Invalid endDate format. Use ISO 8601.', 400));
      }

      query.calculatedAt.$lte = end;
    }
  }

  // Validate and sanitize pagination parameters
  const parsedLimit = Math.min(Math.max(parseInt(limit) || 100, 1), 500);  // Max 500
  const parsedSkip = Math.max(parseInt(skip) || 0, 0);

  // Validate sort parameters
  const validSortFields = ['calculatedAt', 'metricType', 'timeRange', 'createdAt'];
  const sortField = validSortFields.includes(sortBy) ? sortBy : 'calculatedAt';
  const sortDirection = sortOrder === 'asc' ? 1 : -1;

  // Execute query with pagination
  const [analytics, total] = await Promise.all([
    Analytics.find(query)
      .sort({ [sortField]: sortDirection })
      .limit(parsedLimit)
      .skip(parsedSkip)
      .exec(),

    Analytics.countDocuments(query)
  ]);

  res.status(200).json({
    success: true,
    count: analytics.length,
    data: analytics,
    pagination: {
      limit: parsedLimit,
      skip: parsedSkip,
      total,
      hasMore: parsedSkip + analytics.length < total
    }
  });
});

/**
 * @desc    Get analytics by specific ID
 * @route   GET /api/analytics/:id
 * @access  Private (JWT protected)
 * @param   {string} req.params.id - Analytics document ID
 * @returns {Object} Single analytics document
 *
 * @example
 * GET /api/analytics/673d8f9a0b2c4e1234567890
 * Authorization: Bearer <token>
 *
 * Response 200:
 * {
 *   "success": true,
 *   "data": { ... }
 * }
 */
export const getAnalyticsById = asyncHandler(async (req, res, next) => {
  const { id } = req.params;

  const analytics = await Analytics.findOne({
    _id: id,
    userId: req.user.id  // Ensure user owns this analytics
  }).exec();

  if (!analytics) {
    return next(
      new ErrorResponse(
        `Analytics not found with ID: ${id}`,
        404
      )
    );
  }

  res.status(200).json({
    success: true,
    data: analytics
  });
});

/**
 * @desc    Get all anomalies for authenticated user
 * @route   GET /api/analytics/anomalies
 * @access  Private (JWT protected)
 * @query   {string} metricType - Optional: Filter by metric type
 * @query   {string} severity - Optional: Filter by severity (low, medium, high)
 * @query   {string} since - Optional: Get anomalies since date (ISO 8601)
 * @query   {number} limit - Optional: Limit results (default: 50)
 * @returns {Array} Array of analytics with anomalies
 *
 * @example
 * GET /api/analytics/anomalies?severity=high&since=2025-11-01
 * Authorization: Bearer <token>
 *
 * Response 200:
 * {
 *   "success": true,
 *   "count": 3,
 *   "data": [
 *     {
 *       "metricType": "steps",
 *       "analytics": {
 *         "anomalyDetected": true,
 *         "anomalyDetails": {
 *           "severity": "high",
 *           "message": "Steps 150% above average"
 *         }
 *       }
 *     }
 *   ]
 * }
 */
export const getAnomalies = asyncHandler(async (req, res, next) => {
  const { metricType, severity, since, limit = 50 } = req.query;

  const options = {};

  if (severity) {
    const validSeverities = ['low', 'medium', 'high'];

    if (!validSeverities.includes(severity)) {
      return next(
        new ErrorResponse(
          `Invalid severity: ${severity}. Must be one of: ${validSeverities.join(', ')}`,
          400
        )
      );
    }

    options.severity = severity;
  }

  if (since) {
    const sinceDate = new Date(since);

    if (isNaN(sinceDate.getTime())) {
      return next(new ErrorResponse('Invalid since date format. Use ISO 8601.', 400));
    }

    options.since = sinceDate;
  }

  // Use static method from Analytics model
  let query = Analytics.find({
    userId: req.user.id,
    'analytics.anomalyDetected': true
  });

  // Apply filters
  if (metricType) {
    query = query.where('metricType').equals(metricType);
  }

  if (severity) {
    query = query.where('analytics.anomalyDetails.severity').equals(severity);
  }

  if (since) {
    query = query.where('calculatedAt').gte(new Date(since));
  }

  const anomalies = await query
    .sort({ calculatedAt: -1 })
    .limit(parseInt(limit) || 50)
    .exec();

  res.status(200).json({
    success: true,
    count: anomalies.length,
    data: anomalies
  });
});

/**
 * @desc    Get user's analytics summary
 * @route   GET /api/analytics/summary
 * @access  Private (JWT protected)
 * @returns {Object} Summary of all analytics
 *
 * @example
 * GET /api/analytics/summary
 * Authorization: Bearer <token>
 *
 * Response 200:
 * {
 *   "success": true,
 *   "data": {
 *     "totalAnalytics": 45,
 *     "byMetricType": { "steps": 15, "calories": 15, "sleep": 15 },
 *     "byTimeRange": { "7day": 15, "30day": 15, "90day": 15 },
 *     "anomaliesDetected": 5,
 *     "currentStreaks": { "steps": 12, "calories": 8 },
 *     "latestUpdate": "2025-11-16T19:00:00Z"
 *   }
 * }
 */
export const getAnalyticsSummary = asyncHandler(async (req, res, next) => {
  const userId = new mongoose.Types.ObjectId(req.user.id);

  // Aggregate analytics summary
  const summary = await Analytics.aggregate([
    {
      $match: { userId: userId }
    },
    {
      $facet: {
        // Total count
        totalAnalytics: [
          { $count: 'count' }
        ],

        // Count by metric type
        byMetricType: [
          { $group: { _id: '$metricType', count: { $sum: 1 } } },
          { $project: { metricType: '$_id', count: 1, _id: 0 } }
        ],

        // Count by time range
        byTimeRange: [
          { $group: { _id: '$timeRange', count: { $sum: 1 } } },
          { $project: { timeRange: '$_id', count: 1, _id: 0 } }
        ],

        // Anomalies detected
        anomaliesDetected: [
          { $match: { 'analytics.anomalyDetected': true } },
          { $count: 'count' }
        ],

        // Latest update
        latestUpdate: [
          { $sort: { calculatedAt: -1 } },
          { $limit: 1 },
          { $project: { calculatedAt: 1, _id: 0 } }
        ],

        // Current streaks (latest 7day analytics per metric)
        currentStreaks: [
          { $match: { timeRange: '7day' } },
          { $sort: { calculatedAt: -1 } },
          {
            $group: {
              _id: '$metricType',
              streak: { $first: '$analytics.streakDays' }
            }
          },
          { $project: { metricType: '$_id', streak: 1, _id: 0 } }
        ]
      }
    }
  ]);

  // Format response
  const formattedSummary = {
    totalAnalytics: summary[0]?.totalAnalytics[0]?.count || 0,
    byMetricType: summary[0]?.byMetricType.reduce((acc, item) => {
      acc[item.metricType] = item.count;
      return acc;
    }, {}) || {},
    byTimeRange: summary[0]?.byTimeRange.reduce((acc, item) => {
      acc[item.timeRange] = item.count;
      return acc;
    }, {}) || {},
    anomaliesDetected: summary[0]?.anomaliesDetected[0]?.count || 0,
    currentStreaks: summary[0]?.currentStreaks.reduce((acc, item) => {
      acc[item.metricType] = item.streak;
      return acc;
    }, {}) || {},
    latestUpdate: summary[0]?.latestUpdate[0]?.calculatedAt || null
  };

  res.status(200).json({
    success: true,
    data: formattedSummary
  });
});

/**
 * @desc    Delete analytics by ID (admin only - for testing)
 * @route   DELETE /api/analytics/:id
 * @access  Private (JWT protected)
 * @param   {string} req.params.id - Analytics document ID
 * @returns {Object} Success message
 *
 * Note: In production, analytics should auto-expire via TTL index.
 * This endpoint is primarily for testing and manual cleanup.
 */
export const deleteAnalytics = asyncHandler(async (req, res, next) => {
  const { id } = req.params;

  const analytics = await Analytics.findOneAndDelete({
    _id: id,
    userId: req.user.id  // Ensure user owns this analytics
  });

  if (!analytics) {
    return next(
      new ErrorResponse(
        `Analytics not found with ID: ${id}`,
        404
      )
    );
  }

  res.status(200).json({
    success: true,
    message: 'Analytics deleted successfully',
    data: {}
  });
});