/**
 * @fileoverview Analytics Model - Stores processed analytics results from Apache Spark
 * @module models/Analytics
 * @description
 * This model stores analytics insights generated by the Apache Spark streaming engine,
 * including rolling averages, trends, anomaly detection, and streak tracking.
 *
 * Data Flow: Spark Streaming ‚Üí MongoDB Analytics Collection ‚Üí SSE ‚Üí Frontend
 *
 * Features:
 * - Rolling averages (7-day, 30-day, 90-day)
 * - Trend analysis (up/down/stable)
 * - Anomaly detection with severity levels
 * - Streak tracking (goal achievement)
 * - Percentile calculations
 * - Period-over-period comparisons
 * - TTL auto-cleanup (90 days)
 *
 * Indexes:
 * - Single: userId, calculatedAt (for time-series queries)
 * - Compound: (userId + metricType + timeRange) for latest analytics queries
 * - TTL: expiresAt with expireAfterSeconds: 0 (auto-cleanup)
 *
 * @requires mongoose
 * @created 2025-11-16
 * @updated 2025-11-16
 */

import mongoose from 'mongoose';

/**
 * Enum for supported metric types (matches HealthMetric model)
 * These are phone-supported metrics only - no wearable data
 */
const METRIC_TYPES = [
  'steps',
  'distance',
  'calories',
  'activeMinutes',
  'weight',
  'sleepHours',
  'heartPoints',     // Google Fit heart points (phone-derived)
  'hydration'        // Water intake tracking
];

/**
 * Enum for time range periods
 * Defines the rolling window for analytics calculations
 */
const TIME_RANGES = [
  '7day',    // Weekly rolling average
  '30day',   // Monthly rolling average
  '90day'    // Quarterly rolling average
];

/**
 * Enum for trend directions
 * Indicates metric movement compared to previous period
 */
const TREND_DIRECTIONS = [
  'up',      // Increasing trend (positive change)
  'down',    // Decreasing trend (negative change)
  'stable'   // No significant change (within threshold)
];

/**
 * Enum for anomaly severity levels
 * Classified based on statistical deviation (IQR method)
 */
const ANOMALY_SEVERITY = [
  'low',     // 1.5x IQR - minor outlier
  'medium',  // 2.0x IQR - moderate outlier
  'high'     // 3.0x IQR - severe outlier
];

/**
 * Analytics Schema Definition
 * Stores processed insights from Apache Spark streaming analytics
 */
const analyticsSchema = new mongoose.Schema(
  {
    /**
     * User reference
     * Links analytics to specific user for data isolation
     * @required
     * @indexed Single index for user-specific queries
     */
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'User ID is required for analytics'],
      index: true  // Single index for user queries
    },

    /**
     * Metric type being analyzed
     * Must match phone-supported metrics from HealthMetric model
     * @required
     * @enum {string} - One of METRIC_TYPES
     */
    metricType: {
      type: String,
      required: [true, 'Metric type is required'],
      enum: {
        values: METRIC_TYPES,
        message: '{VALUE} is not a supported metric type. Must be one of: ' + METRIC_TYPES.join(', ')
      },
      lowercase: true,  // Normalize to lowercase
      trim: true
    },

    /**
     * Time range for rolling calculations
     * Defines the window period for analytics
     * @required
     * @enum {string} - One of TIME_RANGES
     */
    timeRange: {
      type: String,
      required: [true, 'Time range is required'],
      enum: {
        values: TIME_RANGES,
        message: '{VALUE} is not a valid time range. Must be one of: ' + TIME_RANGES.join(', ')
      },
      lowercase: true,
      trim: true
    },

    /**
     * Analytics insights object
     * Contains all processed analytics data from Spark
     */
    analytics: {
      /**
       * Rolling average for the metric over the time range
       * Example: Average steps over last 7 days
       * @type {Number}
       */
      rollingAverage: {
        type: Number,
        required: [true, 'Rolling average is required'],
        min: [0, 'Rolling average cannot be negative'],
        validate: {
          validator: function(value) {
            // Validate based on metric type constraints
            if (this.metricType === 'steps' && value > 100000) return false;
            if (this.metricType === 'calories' && value > 10000) return false;
            if (this.metricType === 'distance' && value > 200) return false;
            if (this.metricType === 'activeMinutes' && value > 1440) return false;
            if (this.metricType === 'sleepHours' && value > 24) return false;
            if (this.metricType === 'weight' && (value < 20 || value > 500)) return false;
            return true;
          },
          message: 'Rolling average exceeds realistic bounds for {PATH}'
        }
      },

      /**
       * Trend direction compared to previous period
       * @enum {string} - 'up', 'down', 'stable'
       */
      trend: {
        type: String,
        required: [true, 'Trend direction is required'],
        enum: {
          values: TREND_DIRECTIONS,
          message: '{VALUE} is not a valid trend. Must be: up, down, or stable'
        },
        lowercase: true,
        trim: true
      },

      /**
       * Percentage change from previous period
       * Positive values indicate increase, negative indicate decrease
       * @type {Number}
       * @example 12.5 means 12.5% increase
       */
      trendPercentage: {
        type: Number,
        default: 0,
        min: [-100, 'Trend percentage cannot be less than -100%'],
        max: [1000, 'Trend percentage exceeds realistic bounds']
      },

      /**
       * Anomaly detection flag
       * True if current value is statistical outlier
       * @type {Boolean}
       */
      anomalyDetected: {
        type: Boolean,
        required: [true, 'Anomaly detection flag is required'],
        default: false
      },

      /**
       * Anomaly details (if detected)
       * Populated when anomalyDetected = true
       */
      anomalyDetails: {
        /**
         * Severity level of anomaly
         * @enum {string} - 'low', 'medium', 'high'
         */
        severity: {
          type: String,
          enum: {
            values: ANOMALY_SEVERITY,
            message: '{VALUE} is not a valid severity level'
          },
          required: function() {
            return this.analytics?.anomalyDetected === true;
          }
        },

        /**
         * Actual value that triggered anomaly
         * @type {Number}
         */
        actualValue: {
          type: Number,
          required: function() {
            return this.analytics?.anomalyDetected === true;
          }
        },

        /**
         * Expected value based on historical data
         * @type {Number}
         */
        expectedValue: {
          type: Number,
          required: function() {
            return this.analytics?.anomalyDetected === true;
          }
        },

        /**
         * Statistical deviation (z-score or IQR multiplier)
         * @type {Number}
         */
        deviation: {
          type: Number,
          required: function() {
            return this.analytics?.anomalyDetected === true;
          }
        },

        /**
         * Human-readable message describing the anomaly
         * @type {String}
         * @example "Steps 76% above average for this period"
         */
        message: {
          type: String,
          required: function() {
            return this.analytics?.anomalyDetected === true;
          },
          maxlength: [500, 'Anomaly message cannot exceed 500 characters']
        },

        /**
         * Date when anomaly occurred (ISO 8601)
         * @type {Date}
         */
        detectedAt: {
          type: Date,
          required: function() {
            return this.analytics?.anomalyDetected === true;
          }
        }
      },

      /**
       * Current streak of consecutive days meeting goals
       * @type {Number}
       * @min 0
       */
      streakDays: {
        type: Number,
        default: 0,
        min: [0, 'Streak days cannot be negative'],
        max: [3650, 'Streak days exceeds realistic bounds (10 years)']  // 10-year maximum
      },

      /**
       * Longest streak achieved historically
       * @type {Number}
       */
      longestStreak: {
        type: Number,
        default: 0,
        min: [0, 'Longest streak cannot be negative']
      },

      /**
       * Date when current streak started
       * @type {Date}
       */
      streakStartDate: {
        type: Date,
        default: null
      },

      /**
       * Percentile ranking (0-100)
       * User's position relative to other users
       * Example: 85 means user is in top 15%
       * @type {Number}
       */
      percentile: {
        type: Number,
        min: [0, 'Percentile must be between 0 and 100'],
        max: [100, 'Percentile must be between 0 and 100'],
        default: 50  // Median by default
      },

      /**
       * Comparison to previous equivalent period
       * Example: This week vs. last week
       */
      comparisonToPrevious: {
        /**
         * Absolute change in value
         * @type {Number}
         */
        absoluteChange: {
          type: Number,
          default: 0
        },

        /**
         * Percentage change
         * @type {Number}
         */
        percentageChange: {
          type: Number,
          default: 0,
          min: [-100, 'Percentage change cannot be less than -100%']
        },

        /**
         * Improvement flag
         * True if change is positive for this metric type
         * Example: steps increase = improvement, weight decrease = improvement
         * @type {Boolean}
         */
        isImprovement: {
          type: Boolean,
          default: null
        }
      },

      /**
       * Statistical measures
       * Additional analytics for advanced insights
       */
      statistics: {
        /**
         * Standard deviation of values in period
         * @type {Number}
         */
        standardDeviation: {
          type: Number,
          min: [0, 'Standard deviation cannot be negative'],
          default: 0
        },

        /**
         * Minimum value in period
         * @type {Number}
         */
        minValue: {
          type: Number,
          default: null
        },

        /**
         * Maximum value in period
         * @type {Number}
         */
        maxValue: {
          type: Number,
          default: null
        },

        /**
         * Median value in period
         * @type {Number}
         */
        medianValue: {
          type: Number,
          default: null
        },

        /**
         * Number of data points used in calculation
         * @type {Number}
         */
        dataPointsCount: {
          type: Number,
          min: [0, 'Data points count cannot be negative'],
          default: 0
        },

        /**
         * Data completeness percentage (0-100)
         * Indicates how many days in period have data
         * @type {Number}
         */
        completenessPercentage: {
          type: Number,
          min: [0, 'Completeness must be between 0 and 100'],
          max: [100, 'Completeness must be between 0 and 100'],
          default: 0
        }
      }
    },

    /**
     * Timestamp when analytics were calculated
     * Used for time-series queries and freshness checks
     * @type {Date}
     * @default Date.now
     * @indexed For efficient time-based queries
     */
    calculatedAt: {
      type: Date,
      default: Date.now,
      required: [true, 'Calculation timestamp is required'],
      index: true  // Index for time-series queries
    },

    /**
     * Expiration date for TTL (Time-To-Live) auto-cleanup
     * MongoDB will automatically delete documents after this date
     * @type {Date}
     * @default 90 days from calculatedAt
     * @indexed TTL index with expireAfterSeconds: 0
     */
    expiresAt: {
      type: Date,
      required: false,  // Optional field
      default: function() {
        // Set expiration to 90 days from now
        const expirationDate = new Date();
        expirationDate.setDate(expirationDate.getDate() + 90);
        return expirationDate;
      },
      validate: {
        validator: function(value) {
          // Expiration date must be in the future
          return value > new Date();
        },
        message: 'Expiration date must be in the future'
      }
    },

    /**
     * Metadata for analytics processing
     * Tracks Spark job information for debugging
     */
    metadata: {
      /**
       * Spark application ID that generated this analytics
       * @type {String}
       */
      sparkJobId: {
        type: String,
        trim: true,
        maxlength: [200, 'Spark job ID cannot exceed 200 characters']
      },

      /**
       * Processing duration in milliseconds
       * @type {Number}
       */
      processingDurationMs: {
        type: Number,
        min: [0, 'Processing duration cannot be negative']
      },

      /**
       * Number of raw data points processed
       * @type {Number}
       */
      dataPointsProcessed: {
        type: Number,
        min: [0, 'Data points processed cannot be negative'],
        default: 0
      },

      /**
       * Spark version used for processing
       * @type {String}
       */
      sparkVersion: {
        type: String,
        trim: true,
        maxlength: [50, 'Spark version cannot exceed 50 characters']
      }
    }
  },
  {
    /**
     * Schema Options
     */
    timestamps: true,  // Adds createdAt and updatedAt automatically

    /**
     * Collection name in MongoDB
     */
    collection: 'analytics',

    /**
     * Optimize for JSON responses
     */
    toJSON: {
      virtuals: true,
      transform: function(doc, ret) {
        // Remove MongoDB-specific fields from JSON output
        delete ret.__v;
        return ret;
      }
    },

    toObject: {
      virtuals: true
    }
  }
);

// ============================================================================
// INDEXES
// ============================================================================

/**
 * Compound Index: (userId + metricType + timeRange)
 * Optimizes queries for latest analytics per user per metric per time range
 * Example query: Get latest 7-day steps analytics for user
 *
 * @index compound
 * @unique false - Allows multiple analytics entries over time
 */
analyticsSchema.index(
  { userId: 1, metricType: 1, timeRange: 1 },
  {
    name: 'analytics_user_metric_timerange',
    background: true  // Build index in background without blocking
  }
);

/**
 * Compound Index: (userId + calculatedAt)
 * Optimizes time-series queries (latest analytics, date ranges)
 * Example query: Get all analytics for user ordered by calculation time
 *
 * @index compound
 */
analyticsSchema.index(
  { userId: 1, calculatedAt: -1 },  // -1 for descending order (newest first)
  {
    name: 'analytics_user_calculated',
    background: true
  }
);

/**
 * TTL Index: expiresAt
 * Automatically deletes documents after expiresAt date passes
 * Prevents unbounded collection growth
 *
 * @index ttl
 * @expireAfterSeconds 0 - Check immediately when expiresAt passes
 *
 * How it works:
 * - MongoDB background task checks every 60 seconds
 * - Deletes documents where expiresAt <= current time
 * - No manual cleanup needed
 */
analyticsSchema.index(
  { expiresAt: 1 },
  {
    name: 'analytics_ttl',
    expireAfterSeconds: 0,  // Delete immediately when expiresAt passes
    background: true
  }
);

/**
 * Index: metricType
 * Optimizes queries filtering by metric type
 * Example: Get all steps analytics across all users
 *
 * @index single
 */
analyticsSchema.index(
  { metricType: 1 },
  {
    name: 'analytics_metric_type',
    background: true
  }
);

// ============================================================================
// VIRTUAL PROPERTIES
// ============================================================================

/**
 * Virtual: isRecent
 * Checks if analytics were calculated within the last hour
 * Useful for determining freshness of data
 *
 * @returns {Boolean}
 */
analyticsSchema.virtual('isRecent').get(function() {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  return this.calculatedAt >= oneHourAgo;
});

/**
 * Virtual: daysUntilExpiration
 * Calculates days remaining until auto-deletion
 *
 * @returns {Number|null}
 */
analyticsSchema.virtual('daysUntilExpiration').get(function() {
  if (!this.expiresAt) return null;

  const now = new Date();
  const diffMs = this.expiresAt - now;
  const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
});

/**
 * Virtual: trendEmoji
 * Returns emoji representation of trend direction
 * Useful for UI display
 *
 * @returns {String}
 */
analyticsSchema.virtual('trendEmoji').get(function() {
  switch (this.analytics?.trend) {
    case 'up': return '‚¨ÜÔ∏è';
    case 'down': return '‚¨áÔ∏è';
    case 'stable': return '‚û°Ô∏è';
    default: return '‚ûñ';
  }
});

// ============================================================================
// INSTANCE METHODS
// ============================================================================

/**
 * Instance Method: hasAnomaly
 * Checks if analytics contains an anomaly
 *
 * @returns {Boolean}
 */
analyticsSchema.methods.hasAnomaly = function() {
  return this.analytics?.anomalyDetected === true;
};

/**
 * Instance Method: getAnomalySeverity
 * Returns anomaly severity or null if no anomaly
 *
 * @returns {String|null} - 'low', 'medium', 'high', or null
 */
analyticsSchema.methods.getAnomalySeverity = function() {
  return this.hasAnomaly() ? this.analytics.anomalyDetails?.severity : null;
};

/**
 * Instance Method: isExpiringSoon
 * Checks if analytics will expire within specified days
 *
 * @param {Number} days - Number of days threshold (default: 7)
 * @returns {Boolean}
 */
analyticsSchema.methods.isExpiringSoon = function(days = 7) {
  if (!this.expiresAt) return false;

  const thresholdDate = new Date();
  thresholdDate.setDate(thresholdDate.getDate() + days);

  return this.expiresAt <= thresholdDate;
};

/**
 * Instance Method: extendExpiration
 * Extends expiration date by specified days
 *
 * @param {Number} days - Number of days to extend (default: 90)
 * @returns {Promise<Analytics>}
 */
analyticsSchema.methods.extendExpiration = async function(days = 90) {
  if (!this.expiresAt) {
    this.expiresAt = new Date();
  }

  this.expiresAt.setDate(this.expiresAt.getDate() + days);
  return await this.save();
};

// ============================================================================
// STATIC METHODS
// ============================================================================

/**
 * Static Method: getLatestForUser
 * Retrieves the most recent analytics for a user's specific metric and time range
 *
 * @param {ObjectId} userId - User's ObjectId
 * @param {String} metricType - Metric type (e.g., 'steps')
 * @param {String} timeRange - Time range (e.g., '7day')
 * @returns {Promise<Analytics|null>}
 *
 * @example
 * const latest = await Analytics.getLatestForUser(userId, 'steps', '7day');
 */
analyticsSchema.statics.getLatestForUser = async function(userId, metricType, timeRange) {
  return await this.findOne({ userId, metricType, timeRange })
    .sort({ calculatedAt: -1 })  // Newest first
    .exec();
};

/**
 * Static Method: getAllForUser
 * Retrieves all analytics for a user with optional filters
 *
 * @param {ObjectId} userId - User's ObjectId
 * @param {Object} options - Filter options
 * @param {String} options.metricType - Filter by metric type
 * @param {String} options.timeRange - Filter by time range
 * @param {Number} options.limit - Limit results (default: 100)
 * @returns {Promise<Array<Analytics>>}
 *
 * @example
 * const analytics = await Analytics.getAllForUser(userId, { metricType: 'steps', limit: 50 });
 */
analyticsSchema.statics.getAllForUser = async function(userId, options = {}) {
  const query = { userId };

  if (options.metricType) query.metricType = options.metricType;
  if (options.timeRange) query.timeRange = options.timeRange;

  return await this.find(query)
    .sort({ calculatedAt: -1 })
    .limit(options.limit || 100)
    .exec();
};

/**
 * Static Method: getAnomaliesForUser
 * Retrieves all analytics with detected anomalies for a user
 *
 * @param {ObjectId} userId - User's ObjectId
 * @param {Object} options - Filter options
 * @param {String} options.severity - Filter by severity ('low', 'medium', 'high')
 * @param {Date} options.since - Filter by date (anomalies after this date)
 * @returns {Promise<Array<Analytics>>}
 *
 * @example
 * const anomalies = await Analytics.getAnomaliesForUser(userId, { severity: 'high' });
 */
analyticsSchema.statics.getAnomaliesForUser = async function(userId, options = {}) {
  const query = {
    userId,
    'analytics.anomalyDetected': true
  };

  if (options.severity) {
    query['analytics.anomalyDetails.severity'] = options.severity;
  }

  if (options.since) {
    query.calculatedAt = { $gte: options.since };
  }

  return await this.find(query)
    .sort({ calculatedAt: -1 })
    .exec();
};

/**
 * Static Method: deleteExpiredManually
 * Manually deletes expired analytics (for testing TTL)
 * Note: MongoDB TTL index handles this automatically every 60 seconds
 *
 * @returns {Promise<Object>} - Deletion result with count
 */
analyticsSchema.statics.deleteExpiredManually = async function() {
  const result = await this.deleteMany({
    expiresAt: { $lte: new Date() }
  });

  return {
    success: true,
    deletedCount: result.deletedCount,
    message: `Deleted ${result.deletedCount} expired analytics entries`
  };
};

/**
 * Static Method: getStreakLeaderboard
 * Retrieves top users by current streak for a metric
 *
 * @param {String} metricType - Metric type (e.g., 'steps')
 * @param {Number} limit - Number of results (default: 10)
 * @returns {Promise<Array>}
 *
 * @example
 * const leaderboard = await Analytics.getStreakLeaderboard('steps', 10);
 */
analyticsSchema.statics.getStreakLeaderboard = async function(metricType, limit = 10) {
  return await this.aggregate([
    {
      $match: {
        metricType,
        timeRange: '7day'  // Use weekly analytics
      }
    },
    {
      $sort: {
        'analytics.streakDays': -1,
        calculatedAt: -1
      }
    },
    {
      $group: {
        _id: '$userId',
        latestAnalytics: { $first: '$$ROOT' }
      }
    },
    {
      $replaceRoot: { newRoot: '$latestAnalytics' }
    },
    {
      $limit: limit
    },
    {
      $lookup: {
        from: 'users',
        localField: 'userId',
        foreignField: '_id',
        as: 'user'
      }
    },
    {
      $unwind: '$user'
    },
    {
      $project: {
        userId: 1,
        userName: '$user.name',
        streakDays: '$analytics.streakDays',
        longestStreak: '$analytics.longestStreak',
        calculatedAt: 1
      }
    }
  ]);
};

// ============================================================================
// PRE-SAVE MIDDLEWARE
// ============================================================================

/**
 * Pre-save Hook: Validate analytics data consistency
 * Runs before every save operation
 */
analyticsSchema.pre('save', function(next) {
  // Ensure anomaly details are present if anomaly is detected
  if (this.analytics?.anomalyDetected === true) {
    if (!this.analytics.anomalyDetails || !this.analytics.anomalyDetails.severity) {
      return next(new Error('Anomaly details are required when anomalyDetected is true'));
    }
  }

  // Clear anomaly details if no anomaly detected
  if (this.analytics?.anomalyDetected === false) {
    this.analytics.anomalyDetails = undefined;
  }

  // Ensure calculatedAt is set
  if (!this.calculatedAt) {
    this.calculatedAt = new Date();
  }

  // Ensure expiresAt is set (90 days from now if not specified)
  if (!this.expiresAt) {
    const expirationDate = new Date();
    expirationDate.setDate(expirationDate.getDate() + 90);
    this.expiresAt = expirationDate;
  }

  next();
});

/**
 * Pre-save Hook: Log analytics creation in development
 */
analyticsSchema.pre('save', function(next) {
  if (process.env.NODE_ENV === 'development' && this.isNew) {
    console.log(`üìä New analytics created: ${this.metricType} (${this.timeRange}) for user ${this.userId}`);
  }
  next();
});

// ============================================================================
// POST-SAVE MIDDLEWARE
// ============================================================================

/**
 * Post-save Hook: Emit SSE event for real-time updates
 * Notifies frontend when new analytics are available
 */
analyticsSchema.post('save', function(doc) {
  // Import SSE service dynamically to avoid circular dependencies
  import('../services/sseService.js')
    .then(({ default: sseService }) => {
      // Emit event to user's SSE stream
      sseService.emitToUser(doc.userId.toString(), 'analytics:updated', {
        type: 'analytics',
        metricType: doc.metricType,
        timeRange: doc.timeRange,
        trend: doc.analytics.trend,
        anomalyDetected: doc.analytics.anomalyDetected,
        calculatedAt: doc.calculatedAt,
        _id: doc._id
      });

      if (process.env.NODE_ENV === 'development') {
        console.log(`üîî SSE event emitted: analytics:updated for user ${doc.userId}`);
      }
    })
    .catch(err => {
      console.error('‚ùå Failed to emit SSE event for analytics:', err.message);
    });
});

// ============================================================================
// MODEL EXPORT
// ============================================================================

/**
 * Analytics Model
 * Represents processed health metrics analytics from Apache Spark
 *
 * @exports Analytics
 */
const Analytics = mongoose.model('Analytics', analyticsSchema);

export default Analytics;
